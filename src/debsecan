#!/usr/bin/python
# debsecan - Debian Security Analyzer
# Copyright (C) 2005 Florian Weimer
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

VERSION = "0.2"

from cStringIO import StringIO
from optparse import OptionParser
import os
import re
import socket
import sys
import types
import urllib
import zlib

######################################################################
# From debian_support in the secure-testing repository.  Needs to be
# kept in sync manually.  (We duplicate here to avoid a library
# dependency, and make it easy to run the script even when it is not
# installed on the system.)

class ParseError(Exception):
    """An exception which is used to signal a parse failure.

    Attributes:

    filename - name of the file
    lineno - line number in the file
    msg - error message

    """

    def __init__(self, filename, lineno, msg):
        assert type(lineno) == types.IntType
        self.filename = filename
        self.lineno = lineno
        self.msg = msg

    def __str__(self):
        return self.msg

    def __repr__(self):
        return "ParseError(%s, %d, %s)" % (`self.filename`,
                                           self.lineno,
                                           `self.msg`)

    def printOut(self, file):
        """Writes a machine-parsable error message to file."""
        file.write("%s:%d: %s\n" % (self.filename, self.lineno, self.msg))
        file.flush()

letterValue = [None] * 256
def initLetterValue():
    c = 0
    for x in range(ord('A'), ord('Z') + 1):
        letterValue[x] = chr(c)
        c += 1
    for x in range(ord('a'), ord('z') + 1):
        letterValue[x] = chr(c)
        c += 1
    for x in "+-.:":
        letterValue[ord(x)] = chr(c)
        c += 1
initLetterValue()
del initLetterValue

class Version:
    """This class implements Debian version numbers."""

    def __init__(self, version):
        """Creates a new Version object."""
        assert type(version) == types.StringType, `version`
        assert version <> ""
        self.__asString = version
        self.__parsed = self.__parse(version)

    def __str__(self):
        return self.__asString

    def __repr__(self):
        return 'Version(%s)' % `self.__asString`

    def __cmp__(self, other):
        """Compares two versions.

        This method implements the algorithm in the Debian Policy."""
        return cmp(self.__parsed, other.__parsed)

    def __parse(self, v, regexp=\
                re.compile(r'^(?:(\d+):)?([A-Za-z0-9.+:-]+?)'
                           + r'(?:-([A-Za-z0-9.+]+))?$')):
        match = regexp.match(v)
        if match is None:
            raise ValueError, "invalid Debian version string"
        (epoch, upstream, debian) = match.groups()
        if epoch is None:
            epoch = 0
        else:
            epoch = int(epoch)
        return (epoch, self.__parse_1(upstream), self.__parse_1(debian))

    def __parse_1(self, x, non_digits=re.compile(r'^([^0-9]*)(.*)$'),
                  digits=re.compile(r'^([0-9]*)(.*)$')):
        l = []
        while x is not None and x <> '':
            (nd, x) = non_digits.match(x).groups()
            (d, x) = digits.match(x).groups()
            nd_l = []
            for ch in nd:
                nd_l.append(letterValue[ord(ch)])
            nd = ''.join(nd_l)
            if d == '':
                d = 0
            else:
                d = int(d)
            l.append(nd)
            l.append(d)
        return l

class PackageFile:
    """A Debian package file.

    Objects of this class can be used to read Debian's Source and
    Packages files."""

    re_field = re.compile(r'^([A-Za-z][A-Za-z0-9-]+):(?:\s+(.*?))?\s*$')
    re_continuation = re.compile(r'^\s+(?:\.|(\S.*?)\s*)$')

    def __init__(self, name, fileObj=None):
        """Creates a new package file object.

        name - the name of the file the data comes from
        fileObj - an alternate data source; the default is to open the
                  file with the indicated name.
        """
        if fileObj is None:
            fileObj = file(name)
        self.name = name
        self.file = fileObj
        self.lineno = 0

    def __iter__(self):
        line = self.file.readline()
        self.lineno += 1
        pkg = []
        while line:
            if line == '\n':
                if len(pkg) == 0:
                    self.raiseSyntaxError('expected package record')
                yield pkg
                pkg = []
                line = self.file.readline()
                self.lineno += 1
                continue

            match = self.re_field.match(line)
            if not match:
                self.raiseSyntaxError("expected package field")
            (name, contents) = match.groups()
            contents = contents or ''

            while True:
                line = self.file.readline()
                self.lineno += 1
                match = self.re_continuation.match(line)
                if match:
                    (ncontents,) = match.groups()
                    if ncontents is None:
                        ncontents = ""
                    contents = "%s\n%s" % (contents, ncontents)
                else:
                    break
            pkg.append((name, contents))
        if pkg:
            yield pkg

    def raiseSyntaxError(self, msg, lineno=None):
        if lineno is None:
            lineno = self.lineno
        raise ParseError(self.name, lineno, msg)

# End of code from debian_support
######################################################################

# Command line parser

def parse_cli():
    """Reads sys.argv and returns an options object."""
    parser = OptionParser(usage="%prog OPTIONS... --suite SUITE")
    parser.add_option("--suite", type="choice",
                      choices=['woody', 'sarge', 'etch', 'sid'],
                      help="set the Debian suite of this installation")
    parser.add_option("--source", metavar="URL",
                      help="sets the URL for the vulnerability information")
    parser.add_option("--status", metavar="NAME",
                      default="/var/lib/dpkg/status",
                      help="name of the dpkg status file")
    parser.add_option("--format", type="choice",
                      choices=['bugs', 'packages', 'summary', 'detail',
                               'report'],
                      default="summary",
                      help="change output format")
    parser.add_option("--only-fixed", action="store_true", dest="only_fixed",
                help="list only vulnerabilities for which a fix is available")
    parser.add_option("--history", default="/var/lib/debsecan/history",
                      metavar="NAME",
                      help="sets the file name of debsecan's internal status "
                      + "file")
    parser.add_option("--update-history", action="store_true",
                      dest="update_history",
                      help="update the history file after reporting")
    parser.add_option("--mailto", help="send report to an email address")
    (options, args) = parser.parse_args()
    if options.suite is None:
        sys.stderr.write("error: the --suite option is required\n")
        sys.exit(1)
    if options.update_history and options.format <> 'report':
        sys.stderr.write("error: --update-history requires report format\n")
        sys.exit(1)
    if options.mailto and options.format <> 'report':
        sys.stderr.write("error: --mailto requires report format\n")
        sys.exit(1)
    if options.format == 'report' and options.only_fixed:
        sys.stderr.write("error: --only-fixed conflicts with report format\n")
        sys.exit(1)
    return options

# Vulnerabilities

class Vulnerability:
    """Stores a vulnerability name/package name combination."""

    urgency_conversion = {' ' : '',
                        'L' : 'low',
                        'M' : 'medium',
                        'H' : 'high'}

    def __init__(self, str):
        """Creates a new vulnerability object from a string."""
        (bug, flags, package, version, description) = str.split(',', 4)
        self.bug = bug
        self.package = package
        self.version = version
        self.description = description
        self.binary_package = flags[0] == 'B'
        self.urgency = self.urgency_conversion[flags[1]]
        self.remote = {'?' : None,
                       'R' : True,
                       ' ' : False}[flags[2]]
        self.fix_available = flags[3] == 'F'

    def is_vulnerable(self, (bin_pkg, bin_ver), (src_pkg, src_ver)):
        """Returns true if the specified binary package is subject to
        this vulnerability."""
        self._parse()
        if self.binary_package and bin_pkg == self.package:
            if self.version:
                return bin_ver < self.version
            else:
                return True
        elif src_pkg == self.package:
            if self.version:
                return src_ver < self.version
            else:
                return True

    def _parse(self):
        """Further parses the object."""
        if type(self.version) == types.StringType:
            if self.version:
                self.version = Version(self.version)
            else:
                self.version = None

class DebsecanOpener(urllib.FancyURLopener):
    version = "debsecan/" + VERSION

def fetch_data(options):
    """Returns a dictionary PACKAGE -> LIST-OF-VULNERABILITIES."""
    url = options.source
    if not url:
        url = "http://secure-testing.debian.net/debian-secure-testing/" \
              "project/debsecan/release/"
    elif url[-1] <> "/":
        url += "/"
    url = url + options.suite
    u = DebsecanOpener().open(url)
    data = []
    while 1:
        d = u.read(4096)
        if d:
            data.append(d)
        else:
            break
    data = StringIO(zlib.decompress(''.join(data)))
    if data.readline() <> "VERSION 0\n":
        sys.stderr.write("error: server sends data in unknown format\n")
        sys.exit(1)

    packages = {}
    for line in data:
        if line[-1:] == '\n':
            line = line[:-1]
        v = Vulnerability(line)
        try:
            packages[v.package].append(v)
        except KeyError:
            packages[v.package] = [v]
    return packages

# Previous state (for incremental reporting)

class History:
    def __init__(self, options):
        self.options = options
        self.history = self._read_history(self.options.history)

    def data(self):
        """Returns a dictionary (BUG, PACKAGE) -> UPDATE-AVAILABLE.
        The result is not shared with the internal dictionary."""
        return self.history.copy()

    def known(self, v):
        """Returns true if the vulnerability is known."""
        return self.history.has_key(v)

    def fixed(self, v):
        """Returns true if the vulnerability is known and has been
        fixed."""
        return self.history.get(v, False)

    def _read_history(self, name):
        """Reads the named history file.  Returns a dictionary
        (BUG, PACKAGE) -> UPDATE-AVAILABLE."""
        try:
            f = file(name)
        except IOError:
            return {}

        line = f.readline()
        if line <> 'VERSION 0\n':
            return {}

        result = {}
        for line in f:
            if line[-1:] == '\n':
                line = line[:-1]
            (bug, package, fixed) = line.split(',')
            result[(bug, package)] = fixed == 'F'
        f.close()
        return result

# Classes for output formatting

class Formatter:
    def __init__(self, target, options):
        self.target = target
        self.options = options
        pass
    def finish(self):
        pass

class BugFormatter(Formatter):
    def __init__(self, target, options):
        self.target = target
        self.bugs = {}
    def record(self, v, bp, sp):
        self.bugs[v.bug] = 1
    def finish(self):
        bugs = self.bugs.keys()
        bugs.sort()
        for b in bugs:
            self.target.write(b)

class PackageFormatter(Formatter):
    def __init__(self, target, options):
        self.target = target
        self.packages = {}
    def record(self, v, (bin_name, bin_version), sp):
        self.packages[bin_name] = 1
    def finish(self):
        packages = self.packages.keys()
        packages.sort()
        for p in packages:
            self.target.write(p)

class SummaryFormatter(Formatter):
    def record(self, v,
               (bin_name, bin_version), (src_name, src_version)):
        notes = []
        if v.fix_available:
            notes.append("fixed")
        if v.remote:
            notes.append("remotely exploitable")
        if v.urgency:
            notes.append(v.urgency + " urgency")
        notes = ', '.join(notes)
        if notes:
            self.target.write("%s %s (%s)" % (v.bug, bin_name, notes))
        else:
            self.target.write("%s %s" % (v.bug, bin_name))

class DetailFormatter(Formatter):
    def record(self, v,
               (bin_name, bin_version), (src_name, src_version)):
        notes = []
        if v.fix_available:
            notes.append("fixed")
        if v.remote:
            notes.append("remotely exploitable")
        if v.urgency:
            notes.append(v.urgency + " urgency")
        notes = ', '.join(notes)
        if notes:
            self.target.write("%s (%s)" % (v.bug, notes))
        else:
            self.target.write(v.bug)
        self.target.write("  " + v.description)
        self.target.write("  installed: %s %s"
                          % (bin_name, bin_version))
        self.target.write("             (built from %s %s)"
                          % (src_name, src_version))
        if v.binary_package:
            k = 'binary'
        else:
            k = 'source'
        if v.fix_available:
            self.target.write("  fixed package: %s %s (%s package)"
                              % (v.package, v.version, k))
        elif v.version:
            self.target.write(
                "  fixed package: %s %s (%s package, not backported)"
                % (v.package, v.version, k))
        else:
            self.target.write("  fixed package: not yet available")
        self.target.write("")

class ReportFormatter(Formatter):
    def __init__(self, target, options):
        self.target = target
        self.bugs = {}
        self.options = options
        self.history = History(self.options)

        # self.record will put new package status information here.
        self.new_history = {}

        # Fixed bugs are deleted from self.fixed_bugs by self.record.
        self.fixed_bugs = self.history.data()

    def _write_history(self, name):
        """Writes self.new_history to the named history file.
        The file is replaced atomically."""
        new_name = name + '.new'
        f = file(new_name, "w+")
        f.write("VERSION 0\n")
        for ((bug, package), fixed) in self.new_history.items():
            if fixed:
                fixed = 'F'
            else:
                fixed = ' '
            f.write("%s,%s,%s\n" % (bug, package, fixed))
        f.close()
        os.rename(new_name, name)

    def record(self, v,
               (bin_name, bin_version), (src_name, src_version)):

        if self.bugs.has_key(v.bug):
            self.bugs[v.bug].append(v)
        else:
            self.bugs[v.bug] = [v]
        bn = (v.bug, bin_name)
        self.new_history[bn] = v.fix_available
        try:
            del self.fixed_bugs[bn]
        except KeyError:
            pass

    def _status_changed(self):
        """Returns true if the system's vulnerability status changed
        since the last run."""

        for (k, v) in self.new_history.items():
            if (not self.history.has_key(k)) or self.history[k] <> v:
                return True
        return len(self.fixed_bugs.keys()) > 0

    def finish(self):
        if self.options.mailto and not self._status_changed():
            return

        w = self.target.write
        w("Security report based on the %s release " % self.options.suite)
        w("")

        for vlist in self.bugs.values():
            vlist.sort(lambda a, b: cmp(a.package, b.package))

        blist = self.bugs.items()
        blist.sort()

        def scan(fix_status, new_status):
            first_bug = True
            for (bug, vlist) in blist:
                first_pkg = True
                for v in vlist:
                    if v.fix_available:
                        is_new = not self.history.fixed((v.bug, v.package))
                    else:
                        is_new = (not self.history.known((v.bug, v.package))) \
                                 or self.history.fixed((v.bug, v.package))
                    if v.fix_available <> fix_status or is_new <> new_status:
                        continue

                    if first_bug:
                        if fix_status:
                            if new_status:
                                w("*** New security updates")
                            else:
                                w("*** Available security updates")
                        else:
                            if new_status:
                                w("*** New vulnerabilities")
                            else:
                                w("*** Vulnerabilities without updates")
                        w("")
                        first_bug = False
                    if first_pkg:
                        w("%s %s" % (v.bug, v.description))
                        first_pkg = False
                    notes = []
                    if v.remote:
                        notes.append("remotely exploitable")
                    if v.urgency:
                        notes.append(v.urgency + " urgency")
                    notes = ', '.join(notes)
                    if notes:
                        w("  - %s (%s)" % (v.package, notes))
                    else:
                        w("  - %s" % v.package)
                    w("")

        def scan_fixed():
            first_bug = True
            old_bug = ''
            for (bug, package) in self.fixed_bugs.keys():
                if first_bug:
                    w("*** Fixed vulnerabilities")
                    first_bug = False
                if bug <> old_bug:
                    w("")
                    w(bug)
                w("  - %s" % package)
            if not first_bug:
                w("")

        scan(fix_status=True, new_status=True)
        scan_fixed()
        scan(fix_status=True, new_status=False)
        scan(fix_status=False, new_status=True)
        scan(fix_status=False, new_status=False)

        if options.update_history:
            self._write_history(self.options.history)

formatters = {'bugs' : BugFormatter,
              'packages' : PackageFormatter,
              'summary' : SummaryFormatter,
              'detail' : DetailFormatter,
              'report' : ReportFormatter}

# Targets

class Target:
    def __init__(self, options):
        pass
    def finish(self):
        pass

class TargetMail(Target):
    def __init__(self, options):
        assert options.mailto
        self.options = options
        self.sendmail = None

    def _open(self):
        self.sendmail = os.popen("/usr/sbin/sendmail -t", "w")
        self.sendmail.write("""Subject: Debian security status of %s
To: %s

""" % (socket.gethostname(), self.options.mailto))

    def write(self, line):
        if self.sendmail is None:
            self._open()
        self.sendmail.write(line + '\n')

    def finish(self):
        if self.sendmail is not None:
            self.sendmail.close()

class TargetPrint(Target):
    def write(self, line):
        print line


def rate_system(target, options, vulns):
    """Read /var/lib/dpkg/status and discover vulnerable packages.
    The results are printed using one of the formatter classes.

    options: command line options
    vulns: list of vulnerabiltiies"""
    packages = PackageFile(options.status)
    re_source = re.compile\
                (r'^([a-zA-Z0-9.+-]+)(?:\s+\(([a-zA-Z0-9.+:-]+)\))?$')
    formatter = formatters[options.format](target, options)
    for pkg in packages:
        pkg_name = None
        pkg_status = None
        pkg_version = None
        pkg_arch = None
        pkg_source = None
        pkg_source_version = None

        for (name, contents) in pkg:
            if name == "Package":
                pkg_name = contents
            if name == "Status":
                pkg_status = contents
            elif name == "Version":
                pkg_version = Version(contents)
            elif name == "Source":
                match = re_source.match(contents)
                if match is None:
                    raise SyntaxError(('package %s references '
                                       + 'invalid source package %s') %
                                      (pkg_name, `contents`))
                (pkg_source, pkg_source_version) = match.groups()
        if pkg_name is None:
            raise SyntaxError\
                  ("package record does not contain package name")
        if pkg_status is None:
            raise SyntaxError\
                  ("package record does not contain status")
        if 'installed' not in pkg_status.split(' '):
            # Package is not installed.
            continue
        if pkg_version is None:
            raise SyntaxError\
                  ("package record does not contain version information")
        if not pkg_source:
            pkg_source = pkg_name
        if pkg_source_version:
            pkg_source_version = Version(pkg_source_version)
        else:
            pkg_source_version = pkg_version
        try:
            vlist = vulns[pkg_source]
        except KeyError:
            try:
                vlist = vulns[pkg_name]
            except:
                continue
        for v in vlist:
            bp = (pkg_name, pkg_version)
            sp = (pkg_source, pkg_source_version)
            if v.is_vulnerable (bp, sp):
                if options.only_fixed and not v.fix_available:
                    continue
                formatter.record(v, bp, sp)
    formatter.finish()
    target.finish()

if __name__ == "__main__":
    options = parse_cli()
    if options.mailto:
        target = TargetMail(options)
    else:
        target = TargetPrint(options)
    rate_system(target, options, fetch_data(options))
